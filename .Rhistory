winnerFn(3,1,2,4)
winnerFn(4,4,2,4)
winnerFn(1,4,2,3)
winnerFn(1,4,2,4)
sample(c("a","b"),4)
sample(c("a","b"),4,replace = T)
average(c(TRUE,FALSE))
mean(c(TRUE,FALSE,TRUE,TRUE,FALSE))
s <- sample(c("r","a"), 4, replace = T, prob = c(0.6, 1-0.6))
sum(s[s=="r"])
s[s=="r"]
count(s[s=="r"])
s[which(s=="r")]
library(tidyverse)
count(s[s=="r"])
sum(s=="r")
sum(s=="a")
a <- "3"
a != "2"
pRogerPoint = 0.6
runningScoreFn = function(pointHistory){
playerUni = sort(unique(pointHistory))
cols = sapply(playerUni, function(thisPlayer){
cumsum(pointHistory == thisPlayer)
})
names(cols) = playerUni
cbind(pointHistory, as.data.frame(cols))
}
pointHistory = c("r", "r", "a", "r", "a", "r")
runningScoreFn(pointHistory)
winnerFn <- function(andy, roger, winBy, winningScore){
#winByis the number of points one player has over the other to win
#winningScore is the number of points a player needs to win
if((sum(c(andy, roger)>=winningScore)>0)&&(abs(andy-roger)>=winBy)){
return(ifelse(andy>roger,"a", "r"))
}
return("nobody")
}
rogerWinsGameFn <- function(pRogerPoint){
#returns TRUE if Roger wins
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
result <- winnerFn(a, r, 2, 4)
}
#print(c(a,r,p))
return(ifelse(a>r,FALSE, TRUE))
}
i1 <- 1
pa <- rep(FALSE,10000)
repeat{
if(i1>10000){break}
pa[i1] <- rogerWinsGameFn(pRogerPoint)
i1 <- i1 + 1
}
pRogerGame <- mean(pa)
pRogerGame
whoWinsGameFn <- function(pRogerPoint, winBy, winningScore){
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
if((sum(c(a, r)>=winningScore)>0)&&(abs(a-r)>=winBy)){
result <- ifelse(a > r,"a", "r")
}
}
rlist <- list(runningScore = runningScoreFn(p), winner = result)
return(rlist)
}
rogerWinsSetFn <- function(pRogerGame){
return(whoWinsGameFn(pRogerGame, 2, 6))
}
rogerWinsSetFn(pRogerGame)
i2 <- 1
pb <- rep(NA,10000)
repeat{
if(i2>10000){break}
pb[i2] <- rogerWinsSetFn(pRogerGame)$winner
i2 <- i2 + 1
}
pRogerSet <- mean(pb=="r")
pRogerSet
rogerWinsMatchFn <- function(pRogerSet){
return(whoWinsGameFn(pRogerSet, 0, 3))
}
rogerWinsMatchFn(pRogerSet)
i3 <- 1
pc <- rep(NA,10000)
repeat{
if(i3>10000){break}
pc[i3] <- rogerWinsMatchFn(pRogerSet)$winner
i3 <- i3 + 1
}
pRogerMatch <- mean(pc=="r")
pRogerMatch
pRogerPoint = 0.6
runningScoreFn = function(pointHistory){
playerUni = sort(unique(pointHistory))
cols = sapply(playerUni, function(thisPlayer){
cumsum(pointHistory == thisPlayer)
})
names(cols) = playerUni
cbind(pointHistory, as.data.frame(cols))
}
pointHistory = c("r", "r", "a", "r", "a", "r")
runningScoreFn(pointHistory)
winnerFn <- function(andy, roger, winBy, winningScore){
#winByis the number of points one player has over the other to win
#winningScore is the number of points a player needs to win
if((sum(c(andy, roger)>=winningScore)>0)&&(abs(andy-roger)>=winBy)){
return(ifelse(andy>roger,"a", "r"))
}
return("nobody")
}
rogerWinsGameFn <- function(pRogerPoint){
#returns TRUE if Roger wins
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
result <- winnerFn(a, r, 2, 4)
}
#print(c(a,r,p))
return(ifelse(a>r,FALSE, TRUE))
}
i1 <- 1
pa <- rep(FALSE,10000)
repeat{
if(i1>10000){break}
pa[i1] <- rogerWinsGameFn(pRogerPoint)
i1 <- i1 + 1
}
pRogerGame <- mean(pa)
pRogerGame
whoWinsGameFn <- function(pRogerPoint, winBy, winningScore){
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
if((sum(c(a, r)>=winningScore)>0)&&(abs(a-r)>=winBy)){
result <- ifelse(a > r,"a", "r")
}
}
rlist <- list(runningScore = runningScoreFn(p), winner = result)
return(rlist)
}
rogerWinsSetFn <- function(pRogerGame){
return(whoWinsGameFn(pRogerGame, 2, 6))
}
rogerWinsSetFn(pRogerGame)
i2 <- 1
pb <- rep(NA,10000)
repeat{
if(i2>10000){break}
pb[i2] <- rogerWinsSetFn(pRogerGame)$winner
i2 <- i2 + 1
}
pRogerSet <- mean(pb=="r")
pRogerSet
rogerWinsMatchFn <- function(pRogerSet){
return(whoWinsGameFn(pRogerSet, 0, 3))
}
rogerWinsMatchFn(pRogerSet)
i3 <- 1
pc <- rep(NA,10000)
repeat{
if(i3>10000){break}
pc[i3] <- rogerWinsMatchFn(pRogerSet)$winner
i3 <- i3 + 1
}
pRogerMatch <- mean(pc=="r")
pRogerMatch
c(pRogerGame, pRogerSet, pRogerMatch)
c(A=pRogerGame, B=pRogerSet, C=pRogerMatch)
pRogerPoint = 0.6
runningScoreFn = function(pointHistory){
playerUni = sort(unique(pointHistory))
cols = sapply(playerUni, function(thisPlayer){
cumsum(pointHistory == thisPlayer)
})
names(cols) = playerUni
cbind(pointHistory, as.data.frame(cols))
}
pointHistory = c("r", "r", "a", "r", "a", "r")
runningScoreFn(pointHistory)
winnerFn <- function(andy, roger, winBy, winningScore){
#winByis the number of points one player has over the other to win
#winningScore is the number of points a player needs to win
if((sum(c(andy, roger)>=winningScore)>0)&&(abs(andy-roger)>=winBy)){
return(ifelse(andy>roger,"a", "r"))
}
return("nobody")
}
rogerWinsGameFn <- function(pRogerPoint){
#returns TRUE if Roger wins
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
result <- winnerFn(a, r, 2, 4)
}
#print(c(a,r,p))
return(ifelse(a>r,FALSE, TRUE))
}
i1 <- 1
pa <- rep(FALSE,10000)
repeat{
if(i1>10000){break}
pa[i1] <- rogerWinsGameFn(pRogerPoint)
i1 <- i1 + 1
}
pRogerGame <- mean(pa)
pRogerGame
whoWinsGameFn <- function(pRogerPoint, winBy, winningScore){
result <- "nobody"
p <- NULL
while(result == "nobody"){
p <- c(p, sample(c("r","a"), 1, replace = T, prob = c(pRogerPoint, 1-pRogerPoint)))
a <- sum(p=="a")
r <- sum(p=="r")
if((sum(c(a, r)>=winningScore)>0)&&(abs(a-r)>=winBy)){
result <- ifelse(a > r,"a", "r")
}
}
rlist <- list(runningScore = runningScoreFn(p), winner = result)
return(rlist)
}
rogerWinsSetFn <- function(pRogerGame){
return(whoWinsGameFn(pRogerGame, 2, 6))
}
rogerWinsSetFn(pRogerGame)
i2 <- 1
pb <- rep(NA,10000)
repeat{
if(i2>10000){break}
pb[i2] <- rogerWinsSetFn(pRogerGame)$winner
i2 <- i2 + 1
}
pRogerSet <- mean(pb=="r")
pRogerSet
rogerWinsMatchFn <- function(pRogerSet){
return(whoWinsGameFn(pRogerSet, 0, 3))
}
rogerWinsMatchFn(pRogerSet)
i3 <- 1
pc <- rep(NA,10000)
repeat{
if(i3>10000){break}
pc[i3] <- rogerWinsMatchFn(pRogerSet)$winner
i3 <- i3 + 1
}
pRogerMatch <- mean(pc=="r")
pRogerMatch
c(A=pRogerGame, B=pRogerSet, C=pRogerMatch)
a <- 1:9
dim(a)
dim(a) <- c(3:3)
dim(a) <- c(3,3)
a
? dplyr
?? dplyr
a <- as.Date('2020/2/28')
b <- as.Date("2020/3/1")
b -a
a <- c(3,0,TRUE)
b <- c(4,0,FALSE)
a|b
type(14L)
typeof(13L)
a < NA
y <- a/1
y
a <- NA
a/2
a/1
a <- as.Date("2022-12-21")
attr(a)
month(a)
months(a)
a=c(16.52,6.12,0,6.6)
sqrt(sum(a^2))
16.52^2+6.12^2+6.6^2
sqrt(353.9248)
a/sqrt(sum(a^2))
b= c(2.95,30.6,16.8,0)
d=c(14.16,0,16.8,8.36)
b/sqrt(sum(b^2))
d/sqrt(sum(d^2))
idf = c(0.59,1.02,0.56,0.44)
idf/sqrt(sum(idf^2))
q = c(0.59,0,0.56,0.44)
a = c(0.88,0.33,0,0.35)
b = c(0.08,0.87,0.48,0)
d = c(0.6,0,0.71,0.36)
q*a
sum(q*a)
q*b
sum(q*b)
q*c
sum(q*c)
q*d
sum(q*d)
log10(1)
3/log2(2)
3+2/log2(3)
9+3/log2(3)
4+5/log2(5)
6.15+2/log2(7)
3/log2(10)
6.86+0.903
a <- c(6.15, 6.15, rep(6.86,3), 7.76)
a/11.89
setwd("D:/WEN/1102course/Time Series Analysis")
gnp = as.matrix(read.table("3.7  GNP data.txt",header=F))[,1]
gnpgr = diff(log(gnp)) # growth rate
#by checking with the time series plot, it is rather stationary
#the series is different from that shown in the textbook
acf(gnpgr, 24)
pacf(gnpgr, 24)
fit_33 <- arima(gnpgr, order=c(3,0,3)) # ARMA(3,3)
fit_30 <- arima(gnpgr, order=c(3,0,0)) # AR(3)
fit_35 <- arima(gnpgr, order=c(3,0,5))
fit_model <- fit_05
fit_05 <- arima(gnpgr, order=c(0,0,5))
#residual analysis
#(1)
fit_model$residuals  #see R manual
fit_model <- fit_05
acf(gnp, 50)#lag.max=50
gnpgr = diff(log(gnp)) # growth rate
ts.plot(gnpgr)
#by checking with the time series plot, it is rather stationary
#the series is different from that shown in the textbook
acf(gnpgr, 24)
pacf(gnpgr, 24)
#perspective 1: both ACF and PACF tails off => ARMA
#perspective 2: PACF cut off, and ACF tails off => AR(3)
#the patterns of ACF and PACF are different from those in the textbook
fit_33 <- arima(gnpgr, order=c(3,0,3)) # ARMA(3,3)
fit_30 <- arima(gnpgr, order=c(3,0,0)) # AR(3)
# At the beginning, ARMA(3,3) and AR(3) are chosen.
# One might have to tune your model (tune the order p and q) upon the residual analysis.
fit_35 <- arima(gnpgr, order=c(3,0,5))
fit_50 <- arima(gnpgr, order=c(5,0,0))
fit_51 <- arima(gnpgr, order=c(5,0,1))
fit_05 <- arima(gnpgr, order=c(0,0,5))
fit_15 <- arima(gnpgr, order=c(1,0,5))
#residual analysis
#(1)
fit_model$residuals  #see R manual
# 2 alternatives:
#residuals(fit_model)
#resid(fit_model)
ts.plot(fit_model$residuals)
setwd("D:/WEN/1102course/Time Series Analysis")
### Section 3.7  (Building ARIMA Models)
# Analyze the GNP data
# (U.S. gross national product that have been seasonally adjusted)
# can be downloaded from "https://research.stlouisfed.org/"
# target 1947(1) to 2002(3), n=223
gnp = as.matrix(read.table("3.7  GNP data.txt",header=F))[,1]
ts.plot(gnp)
acf(gnp, 50)#lag.max=50
gnpgr = diff(log(gnp)) # growth rate
ts.plot(gnpgr)
#by checking with the time series plot, it is rather stationary
#the series is different from that shown in the textbook
acf(gnpgr, 24)
pacf(gnpgr, 24)
#perspective 1: both ACF and PACF tails off => ARMA
#perspective 2: PACF cut off, and ACF tails off => AR(3)
#the patterns of ACF and PACF are different from those in the textbook
fit_33 <- arima(gnpgr, order=c(3,0,3)) # ARMA(3,3)
fit_30 <- arima(gnpgr, order=c(3,0,0)) # AR(3)
# At the beginning, ARMA(3,3) and AR(3) are chosen.
# One might have to tune your model (tune the order p and q) upon the residual analysis.
fit_35 <- arima(gnpgr, order=c(3,0,5))
fit_50 <- arima(gnpgr, order=c(5,0,0))
fit_51 <- arima(gnpgr, order=c(5,0,1))
fit_05 <- arima(gnpgr, order=c(0,0,5))
fit_15 <- arima(gnpgr, order=c(1,0,5))
#other models suggested in the textbook:
fit_10 <- arima(gnpgr, order=c(1,0,0)) # AR(1)
fit_02 <- arima(gnpgr, order=c(0,0,2)) # MA(2)
#the above two models are similar:
ARMAtoMA(ar=.45, ma=0, 10) # prints psi-weights
#so that the fitted AR(1) and MA(2) models are similar
fit_model <- fit_05
#residual analysis
#(1)
fit_model$residuals  #see R manual
# 2 alternatives:
#residuals(fit_model)
#resid(fit_model)
ts.plot(fit_model$residuals)
fit_model_res = fit_model$residuals
#(2)
library(TSA)
rstandard(fit_model)  #package TSA
ts.plot(rstandard(fit_model), ylab="", main="standardized residuals")
#change in variability => ARCH-type model. no other systematic pattern
#(3)
acf(fit_model_res)
pacf(fit_model_res)
#not satisfactory, further check the Ljung?VBox?VPierce Q-statistic
#(4) construct Fig 3.16
Box.test(fit_model_res, lag=3, type="Ljung-Box")
names(Box.test(fit_model_res, lag=3, type="Ljung-Box"))
B_text_p_value = c(0,0)
for(hh in 3:20){
B_text_p_value[hh] = Box.test(fit_model_res, lag=hh, type="Ljung-Box")$p.value
}
plot(3:20, B_text_p_value[3:20], type="p",
main="p values for Ljung-Box statistic",
xlab="lag", ylab="p value", ylim=c(0,1))
abline(h=0.05, lty=2, col=4)
#results and comments:
# fit_33: residuals not good enough
# fit_50: residuals better, but estimates not good enough
# fit_51: not necessary in term of estimate
# fit_05: residuals perfect, and estimates ok
# fit_15: not necessary in term of estimate
# fit_35: residuals ok, but unstable estimates / not significant estimates
#tsdiag() function can replace the code in (1) ~ (4)
# however, this is a comment in the textbook: The script tsdiag is available in R to run diagnostics for an ARIMA object, however, the script has errors and we do not recommend using it.
setwd("D:/WEN/1102course/Time Series Analysis/project/time-series-final-project")
library(tidyverse)
data <- read.csv("faang_stocks_pandemic_data.csv")
data <- as_tibble(data)
head(data)
# Extract the closing price of Apple and stores in variable "close"
close <- data %>% filter(Name == "Apple") %>% pull(Close)
length(close) # There are 568 observations
# Initialize a time series object
close.ts <- ts(close)
plot(close.ts)
# Test for stationarity
library(tseries)
adf.test(close.ts) # Not stationary
# Differencing one time
apple.ts <- diff(close.ts)
plot(apple.ts) # may be stationary ?
adf.test(apple.ts)
# Choose parameters based on ACF and PACF
acfplot <- acf(apple.ts, plot = F)
pacfplot <- pacf(apple.ts, plot = F)
plot(acfplot) # The ACF of apple.ts cuts off after lag 0
plot(pacfplot) # The PACF of apple.ts tails off
#try both Rate of Return and log(Rate of Return)
close_ror <- diff(close)/close[-568]
#log_ror <- log(close_ror) #it will produce some NaNs if we use log()
#sum(is.na(log_ror))=267
close_ror.ts <- ts(close_ror)
plot(close_ror.ts)
adf.test(close_ror.ts) #p-value=0.01
acf_ror <- acf(close_ror.ts) # The ACF of close_ror.ts cuts off after lag 1?
pacf_ror <- pacf(close_ror.ts) # The PACF of close_ror.ts tails off
library(forecast)
auto.arima(close_ror.ts) #ARIMA(1,0,0)
#try some different data that we might use
#download from: https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series
library("dplyr")
covid <- read_csv("time_series_covid19_confirmed_global.csv")
covid <- covid[,c(-1:-4)]
covid_total <- apply(covid, 2, sum)
covid.ts <- ts(covid_total)
plot(covid.ts)# Not stationary
#refer to result of
#auto.arima(covid.ts) #ARIMA(3,2,4)
#differencing once
d_covid.ts <- diff(covid.ts)
plot(d_covid.ts)
adf.test(d_covid.ts) #p-value = 0.0129
#differencing twice
d_covid.ts <- diff(d_covid.ts)
plot(d_covid.ts) #this graph seems better
adf.test(d_covid.ts) #p-value = 0.01
#d=1? d=2?
acf_covid <- acf(d_covid.ts,150) # The ACF of d_covid.ts tails off
pacf_covid <- pacf(d_covid.ts) # The PACF of d_covid.ts tails off?
arima(d_covid.ts, order=c(3,0,3))
arima(d_covid.ts, order=c(4,0,4))
#refer to result of
auto.arima(covid.ts) #ARIMA(3,2,4)
#differencing once
d_covid.ts <- diff(covid.ts)
arima(covid.ts, order=c(4,2,4))
arima(covid.ts, order=c(4,3,4))
#differencing once
d_covid.ts <- diff(covid.ts)
arima(covid.ts, order=c(6,4,4))
arima(covid.ts, order=c(6,4,4))
arima(covid.ts, order=c(3,3,4))
arima(covid.ts, order=c(3,2,4))
arima(covid.ts, order=c(2,2,4))
arima(covid.ts, order=c(3,2,4))
arima(covid.ts, order=c(3,2,3))
arima(covid.ts, order=c(3,2,5))
arima(covid.ts, order=c(3,2,3))
arima(covid.ts, order=c(4,2,3))
arima(covid.ts, order=c(3,2,3))
